<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Part 12 ‚Äî Phenomenology ‚Ä¢ Pragmatism ‚Ä¢ Analytic (Workshop)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap');
    html,body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; }
    .fade-in { animation: fadeIn .3s ease; }
    @keyframes fadeIn { from {opacity:0; transform: translateY(6px)} to {opacity:1; transform: translateY(0)} }
  </style>
</head>
<body class="bg-gray-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    /************ Reusable Components ************/
    function Badge({children, tone="indigo"}) {
      const tones = {
        indigo: "bg-indigo-100 text-indigo-800",
        green: "bg-green-100 text-green-800",
        blue: "bg-blue-100 text-blue-800",
        purple: "bg-purple-100 text-purple-800",
        yellow: "bg-yellow-100 text-yellow-800",
        red: "bg-red-100 text-red-800",
        gray: "bg-gray-100 text-gray-800"
      };
      return <span className={`inline-block px-2 py-0.5 rounded text-xs font-semibold ${tones[tone]||tones.indigo}`}>{children}</span>
    }

    function SectionCard({title, subtitle, children, icon="üìò"}) {
      return (
        <div className="bg-white rounded-xl shadow-lg border border-gray-200 p-6 fade-in">
          <div className="flex items-start justify-between mb-3">
            <div className="flex items-center space-x-3">
              <span className="text-2xl">{icon}</span>
              <div>
                <h2 className="text-2xl font-bold text-gray-900">{title}</h2>
                {subtitle && <p className="text-gray-600">{subtitle}</p>}
              </div>
            </div>
          </div>
          {children}
        </div>
      )
    }

    function MicroPrimer({ title, items=[], children }) {
      const [open, setOpen] = useState(false);
      return (
        <div className="mt-5 border border-gray-200 rounded-lg overflow-hidden">
          <button onClick={()=>setOpen(o=>!o)} className="w-full flex items-center justify-between px-4 py-3 bg-indigo-50 hover:bg-indigo-100">
            <span className="font-semibold text-indigo-900">Essentials: {title}</span>
            <span className="text-indigo-700">{open ? "‚ñº" : "‚ñ∂"}</span>
          </button>
          {open && (
            <div className="p-4 space-y-4 bg-white">
              {items.map((it,i)=>(
                <div key={i} className="bg-gray-50 p-4 rounded border border-gray-200">
                  <div className="flex items-center justify-between mb-1">
                    <div className="text-sm text-gray-500">{it.term}</div>
                    <Badge tone="gray">{it.tag||"primer"}</Badge>
                  </div>
                  <div className="font-semibold text-gray-900 mb-1">{it.header}</div>
                  <p className="text-gray-800 text-sm mb-2">{it.what}</p>
                  <p className="text-gray-700 text-sm"><span className="font-semibold">Why: </span>{it.why}</p>
                  <div className="text-sm mt-2">
                    <div className="font-semibold">How (3 steps)</div>
                    <ol className="list-decimal list-inside text-gray-700">
                      {it.how.map((h,j)=><li key={j}>{h}</li>)}
                    </ol>
                  </div>
                  {it.pitfalls?.length>0 && (
                    <div className="text-sm mt-2">
                      <div className="font-semibold">Pitfalls</div>
                      <ul className="list-disc list-inside text-gray-700">
                        {it.pitfalls.map((p,k)=><li key={k}>{p}</li>)}
                      </ul>
                    </div>
                  )}
                  <div className="text-xs text-gray-600 mt-2"><span className="font-semibold">Try it:</span> {it.try}</div>
                  <div className="text-xs text-gray-600 mt-1"><span className="font-semibold">ABCD:</span> {it.abcd}</div>
                  <div className="text-xs text-gray-600"><span className="font-semibold">Four Levels:</span> {it.levels}</div>
                </div>
              ))}
              {children}
            </div>
          )}
        </div>
      );
    }

    function QuickCheck({ q, options, correct, onResult }) {
      const [choice, setChoice] = useState(null);
      const [done, setDone] = useState(false);
      const pick = (i)=>{ if (!done) setChoice(i); };
      const submit = ()=>{
        if (choice == null) return;
        setDone(true);
        onResult?.(choice === correct);
      };
      return (
        <div className="mt-4 border rounded p-4">
          <div className="font-semibold mb-2">Quick Check</div>
          <p className="mb-3">{q}</p>
          <div className="space-y-2">
            {options.map((t,i)=>{
              const base = "w-full text-left px-3 py-2 rounded border";
              let cls = "border-gray-200 bg-white hover:bg-gray-50";
              if (done) {
                if (i===correct) cls = "border-green-500 bg-green-50";
                else if (i===choice) cls = "border-red-500 bg-red-50";
                else cls = "border-gray-200 bg-white";
              } else if (choice===i) {
                cls = "border-indigo-500 bg-indigo-50";
              }
              return <button key={i} onClick={()=>pick(i)} className={`${base} ${cls}`}>{t}</button>
            })}
          </div>
          <div className="mt-3 flex justify-end">
            <button onClick={submit}
              className={"px-3 py-2 rounded text-white " + (choice==null ? "bg-gray-300 cursor-not-allowed" : "bg-indigo-600 hover:bg-indigo-700")}>
              Check
            </button>
          </div>
        </div>
      )
    }

    /************ Section Content ************/
    function Phenomenology({onScore}) {
      const [mini, setMini] = useState({obj:"", notes:""});
      const [score, setScore] = useState(0);
      const bump = ok => { setScore(s=>s+(ok?1:0)); onScore?.("phenomenology", ok); };

      const primerItems = [
        {
          term: "Epoch√© / Bracketing",
          header: "Suspend presuppositions to describe what is given.",
          what: "A disciplined pause on theoretical assumptions to describe the structure of experience as it appears.",
          why: "Trains clean observation; reduces theory-ladenness and premature inference.",
          how: [
            "Name the target (e.g., 'the mug on desk').",
            "List features as they appear: figure/ground, texture, affordances.",
            "Withhold causal/explanatory talk; stay with description."
          ],
          pitfalls: ["Sliding into causal stories; smuggling value judgments; vague adjectives without contrasts."],
          try: "60s: describe a pencil's experienced affordances (grasp, balance, tip-feel) with no causal terms.",
          abcd: "A: trained attention ‚Ä¢ B: elegance of crisp descriptions ‚Ä¢ C: lifeworld/task setting ‚Ä¢ D: iterative noticing & refinement",
          levels: "Capacity: attention ‚Üí Capability: bracketing notes ‚Üí Constructor: studio routine ‚Üí Meta: peer critique norms"
        },
        {
          term: "Intentionality (Noesis/Noema)",
          header: "Experience is always 'about' something‚Äîmap act/object structure.",
          what: "Every act of consciousness has an object as-meant; chart act (noesis), object-as-presented (noema), and horizons.",
          why: "Clarifies what exactly is attended and how it is meant; reduces ambiguity downstream.",
          how: [
            "State the act (e.g., anticipating, perceiving, remembering).",
            "State the object-as-meant (features, saliences).",
            "List horizons (what‚Äôs expected next / background assumptions)."
          ],
          pitfalls: ["Treating 'aboutness' as inner pictures; skipping horizon notes."],
          try: "Map one act/object pair (e.g., 'waiting for a text') + its horizon.",
          abcd: "A: situated agency ‚Ä¢ B: 'aha' of precise mapping ‚Ä¢ C: everyday context ‚Ä¢ D: horizon-updates with feedback",
          levels: "Capacity: directedness ‚Üí Capability: mapping template ‚Üí Constructor: recurring note-taking ‚Üí Meta: refining templates"
        },
        {
          term: "Phenomenological Reduction",
          header: "From everyday stance to structures of appearance.",
          what: "Shift focus from the 'is-it-true' stance to 'how-it-appears' to reveal invariants of experience.",
          why: "Extracts stable structures (invariants) useful for later modeling or testing.",
          how: [
            "Perform epoch√© on truth/fact questions.",
            "Search for invariants across variants (e.g., grip-feel across cups).",
            "Record contrasts & limits (when the structure breaks)."
          ],
          pitfalls: ["Confusing reduction with skepticism; drifting back to metaphysical claims."],
          try: "Compare two everyday sights: note 2‚Äì3 invariant aspects of 'reading a screen'.",
          abcd: "A: disciplined stance ‚Ä¢ B: elegance of minimal invariants ‚Ä¢ C: context frames appearances ‚Ä¢ D: variant‚Äìinvariant comparisons",
          levels: "Capacity: stance shift ‚Üí Capability: comparative grids ‚Üí Constructor: lab protocol ‚Üí Meta: method revision"
        }
      ];

      return (
        <SectionCard
          title="Phenomenology ‚Äî 'Back to the things themselves'"
          subtitle="Structure of experience, description before explanation"
          icon="üëÅÔ∏è"
        >
          <div className="space-y-4">
            <p className="text-gray-700">
              <span className="font-semibold">Big question:</span> What is the structure of experience and its directedness?
              &nbsp;<span className="font-semibold">Capabilities:</span> epoch√©/bracketing; act‚Äìobject mapping; horizon analysis.
            </p>
            <div className="flex flex-wrap gap-2">
              <Badge tone="blue">A: Situated Agency</Badge>
              <Badge tone="purple">C: Forms of Life / Lifeworld</Badge>
              <Badge tone="green">D: Iterative noticing</Badge>
              <Badge tone="indigo">B: Elegance of clear descriptions</Badge>
            </div>

            <MicroPrimer title="Phenomenology (epoch√©, bracketing, intentionality)" items={primerItems}>
              <QuickCheck
                q="Which action best exemplifies epoch√© during observation?"
                options={[
                  "Explaining why the mug was manufactured that way",
                  "Describing grip/weight/rim feel without theory",
                  "Inferring the designer‚Äôs intentions",
                  "Comparing two brands‚Äô pricing strategies"
                ]}
                correct={1}
                onResult={bump}
              />
              <QuickCheck
                q="In intentional analysis, the 'horizon' refers to:"
                options={[
                  "Background expectations and possible nexts",
                  "The object‚Äôs price and warranty",
                  "The camera‚Äôs depth of field",
                  "A distant mountain range"
                ]}
                correct={0}
                onResult={bump}
              />
            </MicroPrimer>

            <div className="mt-4 p-4 bg-gray-50 border rounded">
              <div className="font-semibold mb-2">Mini-Lab: 90-second description without theory</div>
              <p className="text-sm text-gray-700 mb-2">Pick a mundane object and perform bracketing. Capture only appearances.</p>
              <input
                className="w-full border rounded px-3 py-2 mb-2"
                placeholder="Object (e.g., 'coffee mug')"
                value={mini.obj}
                onChange={(e)=>setMini({...mini, obj:e.target.value})}
              />
              <textarea
                className="w-full border rounded px-3 py-2 h-28"
                placeholder="Write 4‚Äì6 lines describing figure/ground, texture, affordances, immediate feel, horizons‚Ä¶"
                value={mini.notes}
                onChange={(e)=>setMini({...mini, notes:e.target.value})}
              />
            </div>
          </div>
        </SectionCard>
      );
    }

    function Pragmatism({onScore}) {
      const [plan, setPlan] = useState({problem:"", hypothesis:"", consequences:"", test:""});
      const bump = ok => onScore?.("pragmatism", ok);

      const items = [
        {
          term: "Inquiry Cycle (Dewey)",
          header: "Problem ‚Üí Hypothesis ‚Üí Consequences ‚Üí Experiment ‚Üí Learning",
          what: "Ideas are tools; truth tracks what reliably works for resolving the felt difficulty.",
          why: "Turns philosophy into an engineering workshop for lived problems.",
          how: [
            "State a concrete problematic situation.",
            "Frame a plausible hypothesis for resolving it.",
            "Derive observable consequences to test."
          ],
          pitfalls: ["Vague 'problems'; hypotheses with no observable bite; skipping post-test learning."],
          try: "Pick a small friction in your routine; write 1 hypothesis + 2 testable consequences.",
          abcd: "A: agent recalibration ‚Ä¢ B: 'aha' when it works ‚Ä¢ C: task/equipment setting ‚Ä¢ D: problem‚Äìtool loops",
          levels: "Capacity: improvise ‚Üí Capability: inquiry template ‚Üí Constructor: team retros ‚Üí Meta: process improvement"
        },
        {
          term: "Abduction, Induction, Deduction (Peirce)",
          header: "Generate ‚Üí Support ‚Üí Imply",
          what: "Abduction proposes a candidate explanation; induction estimates support; deduction yields testable implications.",
          why: "Decomposes reasoning so each step can be checked or improved.",
          how: [
            "Abduce: suggest an explanatory pattern.",
            "Induce: gather data to update credence.",
            "Deduce: specify predictions and tests."
          ],
          pitfalls: ["Treating abduction as proof; induction from tiny samples; deductions with undefined terms."],
          try: "Abduce a reason for a recurring error; list 2 observations that would raise/lower confidence.",
          abcd: "A: creative agency ‚Ä¢ B: elegance of a unifying hunch ‚Ä¢ C: evidence ecology ‚Ä¢ D: update cycles",
          levels: "Capacity: guess ‚Üí Capability: structured updates ‚Üí Constructor: lab notebook ‚Üí Meta: method-tuning"
        },
        {
          term: "Warranted Assertability (Dewey)",
          header: "Justification is context-sensitive and practice-bound.",
          what: "A claim is warranted when, given present tools and checks, it stands up to inquiry aimed at the problem.",
          why: "Focuses justification on what matters for action now, yet remains revisable.",
          how: [
            "Name the standards relevant to this problem.",
            "Show checks passed (replication, counterfactuals).",
            "Record failure modes and revisit cadence."
          ],
          pitfalls: ["Treating warrant as permanent; ignoring domain standards; 'trust me' warrants."],
          try: "Write warrant criteria for a study habit change you plan to test next week.",
          abcd: "A: accountable agency ‚Ä¢ B: satisfying closure ‚Ä¢ C: institutional checks ‚Ä¢ D: scheduled revisits",
          levels: "Capacity: justify ‚Üí Capability: checklists ‚Üí Constructor: review ritual ‚Üí Meta: governance updates"
        }
      ];

      return (
        <SectionCard
          title="Pragmatism ‚Äî Inquiry as problem-solving"
          subtitle="Ideas as tools; truth as what works in practice under scrutiny"
          icon="üõ†Ô∏è"
        >
          <div className="space-y-4">
            <p className="text-gray-700">
              <span className="font-semibold">Big question:</span> How do we turn puzzlement into improved action?
              &nbsp;<span className="font-semibold">Capabilities:</span> formulating problems, designing hypotheses, specifying testable consequences, learning.
            </p>
            <div className="flex flex-wrap gap-2">
              <Badge tone="blue">A: Situated Agency</Badge>
              <Badge tone="purple">C: Labs / Studios</Badge>
              <Badge tone="green">D: Problem‚ÄìHypothesis‚ÄìTool Cycles</Badge>
              <Badge tone="indigo">B: Elegance of clean tests</Badge>
            </div>

            <MicroPrimer title="Pragmatic Inquiry (Dewey/Peirce)" items={items}>
              <QuickCheck
                q="Which ordering matches Peirce‚Äôs triad?"
                options={[
                  "Induction ‚Üí Abduction ‚Üí Deduction",
                  "Abduction ‚Üí Induction ‚Üí Deduction",
                  "Deduction ‚Üí Abduction ‚Üí Induction",
                  "Abduction ‚Üí Deduction ‚Üí Induction"
                ]}
                correct={1}
                onResult={bump}
              />
              <QuickCheck
                q="In Dewey‚Äôs model, 'warrant' is best understood as:"
                options={[
                  "A permanent proof of truth",
                  "Context-free certainty",
                  "Practice-bound justification under current checks",
                  "A personal conviction that feels strong"
                ]}
                correct={2}
                onResult={bump}
              />
            </MicroPrimer>

            <div className="mt-4 p-4 bg-gray-50 border rounded">
              <div className="font-semibold mb-2">Mini-Lab: Build a one-page inquiry</div>
              <div className="grid md:grid-cols-2 gap-3">
                <textarea className="border rounded px-3 py-2 h-28" placeholder="Problem (felt difficulty)‚Ä¶"
                  value={plan.problem} onChange={e=>setPlan({...plan, problem:e.target.value})}/>
                <textarea className="border rounded px-3 py-2 h-28" placeholder="Hypothesis (tool/approach that could resolve it)‚Ä¶"
                  value={plan.hypothesis} onChange={e=>setPlan({...plan, hypothesis:e.target.value})}/>
                <textarea className="border rounded px-3 py-2 h-28" placeholder="Observable consequences (what you‚Äôd see if the hypothesis works)‚Ä¶"
                  value={plan.consequences} onChange={e=>setPlan({...plan, consequences:e.target.value})}/>
                <textarea className="border rounded px-3 py-2 h-28" placeholder="Test (procedure, measures, stop conditions)‚Ä¶"
                  value={plan.test} onChange={e=>setPlan({...plan, test:e.target.value})}/>
              </div>
            </div>
          </div>
        </SectionCard>
      );
    }

    function Analytic({onScore}) {
      const [work, setWork] = useState({claim:"", terms:"", counter:"", form:"", ops:""});
      const bump = ok => onScore?.("analytic", ok);

      const items = [
        {
          term: "Concept Analysis",
          header: "Clarify necessary/sufficient conditions; hunt counterexamples.",
          what: "Audit a concept by proposing conditions and testing them with cases (Gettier-style pressure tests).",
          why: "Sharpens meanings before arguments; prevents equivocation.",
          how: [
            "List candidate conditions (N/S).",
            "Construct counterexamples (too broad/narrow).",
            "Revise the analysis iteratively."
          ],
          pitfalls: ["Equivocation; definitions that merely re-label; ignoring borderline cases."],
          try: "Pick 'consent' or 'knowledge'; write 2 conditions + 1 counterexample each.",
          abcd: "A: disciplined attention ‚Ä¢ B: elegance of minimal definitions ‚Ä¢ C: case libraries ‚Ä¢ D: refine via counterexamples",
          levels: "Capacity: define ‚Üí Capability: case-testing ‚Üí Constructor: shared exemplars ‚Üí Meta: update definitions"
        },
        {
          term: "Logical Form",
          header: "Surface structure ‚Üí underlying argument form.",
          what: "Translate natural language into standard forms (modus ponens/tollens, quantifiers) to assess validity.",
          why: "Separates content from structure; reveals fallacies.",
          how: [
            "Paraphrase premises & conclusion cleanly.",
            "Symbolize key claims; mark quantifiers.",
            "Check validity; locate illicit steps."
          ],
          pitfalls: ["Over-symbolizing; dropping indexicals; hiding ambiguity under symbols."],
          try: "Symbolize: 'If effort matters, grades shouldn‚Äôt be pure curve; effort matters; so no pure curve.'",
          abcd: "A: agency in editing arguments ‚Ä¢ B: elegant proofs ‚Ä¢ C: classroom or debate setting ‚Ä¢ D: proof/refutation loops",
          levels: "Capacity: parse ‚Üí Capability: symbolize ‚Üí Constructor: proof routines ‚Üí Meta: system comparisons"
        },
        {
          term: "Ordinary vs. Ideal Language",
          header: "When to use ordinary-use analysis vs. ideal precisification.",
          what: "Ordinary language maps lived use; ideal language offers precision for logic/models‚Äîpick deliberately.",
          why: "Prevents category errors; blends clarity with relevance.",
          how: [
            "Check ordinary uses & implicatures.",
            "Specify a targeted idealization for analysis.",
            "Cross-validate: does the idealization distort stakes?"
          ],
          pitfalls: ["Forcing everyday disputes into exotic jargon; or staying vague when precision is needed."],
          try: "Take 'fairness' in grading; contrast ordinary uses with a precise operationalization.",
          abcd: "A: fit to practices ‚Ä¢ B: neat alignments ‚Ä¢ C: setting demands ‚Ä¢ D: iterate between uses and models",
          levels: "Capacity: notice uses ‚Üí Capability: choose frame ‚Üí Constructor: style guide ‚Üí Meta: community norms"
        }
      ];

      return (
        <SectionCard
          title="Analytic Philosophy ‚Äî Clarity, form, and method"
          subtitle="Concept audit, logical form, operationalization"
          icon="üß†"
        >
          <div className="space-y-4">
            <p className="text-gray-700">
              <span className="font-semibold">Big question:</span> What‚Äôs the claim, what does it mean, and does the argument hold?
              &nbsp;<span className="font-semibold">Capabilities:</span> concept analysis, formal validity checks, operational definitions.
            </p>
            <div className="flex flex-wrap gap-2">
              <Badge tone="blue">A: Situated Agency (editing arguments)</Badge>
              <Badge tone="purple">C: Forms of Life (seminars, debate)</Badge>
              <Badge tone="green">D: Proof / Refutation Iterations</Badge>
              <Badge tone="indigo">B: Elegance of proofs/definitions</Badge>
            </div>

            <MicroPrimer title="Analytic Toolkit" items={items}>
              <QuickCheck
                q="A good counterexample to a proposed definition shows that it is:"
                options={[
                  "Too broad or too narrow",
                  "Grammatically incorrect",
                  "Psychologically implausible",
                  "Historically unpopular"
                ]}
                correct={0}
                onResult={bump}
              />
              <QuickCheck
                q="Symbolizing an argument primarily helps you:"
                options={[
                  "Avoid dealing with evidence",
                  "Hide ambiguities",
                  "Expose validity/invalidity of structure",
                  "Win debates by intimidation"
                ]}
                correct={2}
                onResult={bump}
              />
            </MicroPrimer>

            <div className="mt-4 p-4 bg-gray-50 border rounded">
              <div className="font-semibold mb-2">Mini-Lab: Concept ‚Üí Form ‚Üí Ops</div>
              <div className="grid md:grid-cols-2 gap-3">
                <textarea className="border rounded px-3 py-2 h-24" placeholder="Target claim (natural language)‚Ä¶"
                  value={work.claim} onChange={e=>setWork({...work, claim:e.target.value})}/>
                <textarea className="border rounded px-3 py-2 h-24" placeholder="Key terms (necessary/sufficient conditions)‚Ä¶"
                  value={work.terms} onChange={e=>setWork({...work, terms:e.target.value})}/>
                <textarea className="border rounded px-3 py-2 h-24" placeholder="Counterexample(s)‚Ä¶"
                  value={work.counter} onChange={e=>setWork({...work, counter:e.target.value})}/>
                <textarea className="border rounded px-3 py-2 h-24" placeholder="Logical form (‚Üí, ‚àß, ‚à®, ‚àÄ, ‚àÉ)‚Ä¶"
                  value={work.form} onChange={e=>setWork({...work, form:e.target.value})}/>
              </div>
              <textarea className="mt-3 border rounded px-3 py-2 w-full h-24"
                placeholder="Operationalization (what observations count? thresholds? measures?)"
                value={work.ops} onChange={e=>setWork({...work, ops:e.target.value})}/>
            </div>
          </div>
        </SectionCard>
      );
    }

    /************ Studio: turn a philosophical claim into a testable workflow ************/
    function Studio({ phenReady, pragReady, analReady }) {
      const [mode, setMode] = useState("pragmatism"); // or phenomenology / analytic
      const [claim, setClaim] = useState("");
      const [output, setOutput] = useState("");

      const makePlan = ()=>{
        const c = claim.trim();
        if (!c) { setOutput("Please enter a claim to transform."); return; }

        if (mode === "phenomenology") {
          setOutput([
            "WORKFLOW (Phenomenology)",
            "1) Target & Epoch√©:",
            `   ‚Ä¢ Targeted phenomenon: ${c}`,
            "   ‚Ä¢ Bracket theoretical explanations; commit to description-only session (3‚Äì5 min).",
            "2) Act/Object Mapping:",
            "   ‚Ä¢ Map noesis (act) and noema (object-as-meant); list horizons (expected nexts).",
            "3) Variant‚ÄìInvariant Scan:",
            "   ‚Ä¢ Compare 2‚Äì3 variants; list invariants; mark breakdown points.",
            "4) Record & Share:",
            "   ‚Ä¢ Produce 6‚Äì10 observation lines; peer critique for clarity (no theory creep).",
            "5) Next Iteration:",
            "   ‚Ä¢ Add contrasts; refine invariants; decide if operationalization is ready."
          ].join("\n"));
        } else if (mode === "pragmatism") {
          setOutput([
            "WORKFLOW (Pragmatism)",
            `Claim/tool to probe: ${c}`,
            "1) Problem:",
            "   ‚Ä¢ State a concrete felt difficulty this claim/tool aims to resolve.",
            "2) Hypothesis:",
            "   ‚Ä¢ If we adopt/act on the claim, X consequence should follow in context Y.",
            "3) Consequences:",
            "   ‚Ä¢ List 2‚Äì3 observable outcomes that would count for/against it.",
            "4) Test Plan:",
            "   ‚Ä¢ Procedure, measures, timebox, stop conditions; record failure modes.",
            "5) Warrant:",
            "   ‚Ä¢ State current warrant criteria; schedule revisit; update based on results."
          ].join("\n"));
        } else {
          setOutput([
            "WORKFLOW (Analytic)",
            `Target claim: ${c}`,
            "1) Concept Analysis:",
            "   ‚Ä¢ Define key terms (N/S conditions). Add at least one counterexample & revise.",
            "2) Logical Form:",
            "   ‚Ä¢ Translate to formal structure; test validity; locate any fallacies.",
            "3) Operationalization:",
            "   ‚Ä¢ Specify what observations/thresholds would count as confirmation/disconfirmation.",
            "4) Cross-check (Ordinary vs Ideal):",
            "   ‚Ä¢ Compare ordinary usage with your precisified version; adjust if distorted.",
            "5) Test & Iterate:",
            "   ‚Ä¢ Apply to 2 cases; log misfits; revise the definition or the claim accordingly."
          ].join("\n"));
        }
      };

      const downloadable = useMemo(()=>{
        return new Blob([output], {type:"text/plain"});
      }, [output]);

      return (
        <SectionCard
          title="Design Studio ‚Äî Turn a claim into a testable workflow"
          subtitle="Choose a method lens and auto-build a plan you can trial this week"
          icon="üéõÔ∏è"
        >
          <div className="space-y-3">
            <div className="flex flex-wrap gap-2">
              <Badge tone={phenReady? "green":"gray"}>Phenomenology {phenReady? "‚úì":"‚Ä¢"}</Badge>
              <Badge tone={pragReady? "green":"gray"}>Pragmatism {pragReady? "‚úì":"‚Ä¢"}</Badge>
              <Badge tone={analReady? "green":"gray"}>Analytic {analReady? "‚úì":"‚Ä¢"}</Badge>
            </div>

            <div className="grid md:grid-cols-4 gap-3">
              <div className="md:col-span-3">
                <input className="w-full border rounded px-3 py-2"
                  placeholder="Enter a philosophical claim (e.g., 'Grading fairness requires transparent rubrics')."
                  value={claim} onChange={e=>setClaim(e.target.value)} />
              </div>
              <div className="flex md:col-span-1 gap-2">
                <select className="w-full border rounded px-2 py-2" value={mode} onChange={e=>setMode(e.target.value)}>
                  <option value="phenomenology">Phenomenology</option>
                  <option value="pragmatism">Pragmatism</option>
                  <option value="analytic">Analytic</option>
                </select>
                <button onClick={makePlan} className="px-4 py-2 rounded bg-indigo-600 text-white hover:bg-indigo-700">Build</button>
              </div>
            </div>

            <textarea className="w-full border rounded px-3 py-2 h-52 bg-white" value={output} readOnly placeholder="Your workflow will appear here‚Ä¶"></textarea>

            <div className="flex flex-wrap gap-2">
              <a
                className={"px-3 py-2 rounded " + (output ? "bg-green-600 text-white hover:bg-green-700" : "bg-gray-300 text-gray-600 cursor-not-allowed")}
                download="workflow.txt"
                href={output ? URL.createObjectURL(downloadable) : undefined}
              >
                Download Plan
              </a>
              <button
                onClick={()=>{ if (output) { navigator.clipboard.writeText(output); alert("Copied to clipboard!"); } }}
                className={"px-3 py-2 rounded " + (output ? "bg-gray-800 text-white hover:bg-black" : "bg-gray-300 text-gray-600 cursor-not-allowed")}
              >
                Copy to Clipboard
              </button>
            </div>
          </div>
        </SectionCard>
      );
    }

    /************ App Shell ************/
    function App() {
      const [student, setStudent] = useState({name:"", email:"", course:""});
      const [ready, setReady] = useState(false);
      const [tab, setTab] = useState("phenomenology"); // phenomenology | pragmatism | analytic | studio | review
      const [scores, setScores] = useState({ phenomenology:0, pragmatism:0, analytic:0 });

      useEffect(()=>{
        const saved = localStorage.getItem("p12_state_v1");
        if (saved) {
          try {
            const obj = JSON.parse(saved);
            if (obj.student) setStudent(obj.student);
            if (obj.tab) setTab(obj.tab);
            if (obj.ready) setReady(obj.ready);
            if (obj.scores) setScores(obj.scores);
          } catch {}
        }
      }, []);
      useEffect(()=>{
        localStorage.setItem("p12_state_v1", JSON.stringify({student, ready, tab, scores}));
      }, [student, ready, tab, scores]);

      const onScore = (sec, ok)=> setScores(s => ({...s, [sec]: s[sec] + (ok?1:0)}));

      const phenReady = scores.phenomenology >= 1;
      const pragReady = scores.pragmatism >= 1;
      const analReady = scores.analytic >= 1;

      if (!ready) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-indigo-600 to-purple-700 text-white">
            <div className="max-w-4xl mx-auto px-4 py-12">
              <div className="bg-white/10 rounded-xl p-8 shadow-xl">
                <h1 className="text-3xl font-extrabold mb-2">Part 12 ‚Äî Phenomenology ‚Ä¢ Pragmatism ‚Ä¢ Analytic</h1>
                <p className="opacity-90 mb-6">
                  The Braid of Philosophy as a workshop: turn classic methods into practical capabilities.
                </p>

                <div className="grid md:grid-cols-3 gap-4 mb-4">
                  <div className="bg-white/10 rounded p-4">
                    <div className="text-xl">üëÅÔ∏è</div>
                    <div className="font-semibold">Phenomenology</div>
                    <div className="text-sm opacity-90">Description before explanation</div>
                  </div>
                  <div className="bg-white/10 rounded p-4">
                    <div className="text-xl">üõ†Ô∏è</div>
                    <div className="font-semibold">Pragmatism</div>
                    <div className="text-sm opacity-90">Inquiry as problem-solving</div>
                  </div>
                  <div className="bg-white/10 rounded p-4">
                    <div className="text-xl">üß†</div>
                    <div className="font-semibold">Analytic</div>
                    <div className="text-sm opacity-90">Concepts, form, and proofs</div>
                  </div>
                </div>

                <form className="grid gap-3 bg-white rounded-lg text-gray-900 p-4">
                  <div>
                    <label className="text-sm text-gray-600">Full Name *</label>
                    <input className="w-full border rounded px-3 py-2" value={student.name}
                      onChange={e=>setStudent({...student, name:e.target.value})} placeholder="Your full name"/>
                  </div>
                  <div>
                    <label className="text-sm text-gray-600">Email *</label>
                    <input className="w-full border rounded px-3 py-2" value={student.email}
                      onChange={e=>setStudent({...student, email:e.target.value})} placeholder="you@school.edu"/>
                  </div>
                  <div>
                    <label className="text-sm text-gray-600">Course/Section *</label>
                    <input className="w-full border rounded px-3 py-2" value={student.course}
                      onChange={e=>setStudent({...student, course:e.target.value})} placeholder="PHI 101 - 02"/>
                  </div>
                  <button type="button"
                    onClick={()=>{
                      if (student.name && student.email && student.course) setReady(true);
                      else alert("Please fill all fields to continue.");
                    }}
                    className="px-4 py-3 rounded bg-indigo-600 text-white hover:bg-indigo-700">
                    Go to Part 12 ‚Üí
                  </button>
                </form>
              </div>
            </div>
          </div>
        );
      }

      const tabs = [
        {id:"phenomenology", label:"Phenomenology", icon:"üëÅÔ∏è"},
        {id:"pragmatism", label:"Pragmatism", icon:"üõ†Ô∏è"},
        {id:"analytic", label:"Analytic", icon:"üß†"},
        {id:"studio", label:"Design Studio", icon:"üéõÔ∏è"},
        {id:"review", label:"Review & Export", icon:"‚úÖ"}
      ];

      return (
        <div className="min-h-screen">
          <header className="bg-white shadow">
            <div className="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
              <div className="flex items-center space-x-3">
                <span className="text-2xl">üß∞</span>
                <div>
                  <div className="text-lg font-bold">Part 12 ‚Äî Phenomenology ‚Ä¢ Pragmatism ‚Ä¢ Analytic</div>
                  <div className="text-sm text-gray-600">Student: {student.name || "‚Äî"} ¬∑ {student.course || "‚Äî"}</div>
                </div>
              </div>
              <button
                onClick={()=>{
                  if (confirm("Reset all local progress?")) {
                    localStorage.removeItem("p12_state_v1");
                    location.reload();
                  }
                }}
                className="px-3 py-2 rounded bg-gray-100 hover:bg-gray-200 text-gray-800"
              >Reset</button>
            </div>
          </header>

          <nav className="bg-white border-b">
            <div className="max-w-6xl mx-auto px-4">
              <div className="flex overflow-x-auto gap-2 py-3">
                {tabs.map(t=>(
                  <button key={t.id} onClick={()=>setTab(t.id)}
                    className={"px-4 py-2 rounded-lg border " + (tab===t.id ? "border-indigo-500 bg-indigo-50 text-indigo-700"
                      : "border-gray-200 hover:bg-gray-50")}>
                    <span className="mr-2">{t.icon}</span>{t.label}
                  </button>
                ))}
              </div>
            </div>
          </nav>

          <main className="max-w-6xl mx-auto px-4 py-6 space-y-6">
            {tab==="phenomenology" && <Phenomenology onScore={onScore}/>}
            {tab==="pragmatism" && <Pragmatism onScore={onScore}/>}
            {tab==="analytic" && <Analytic onScore={onScore}/>}
            {tab==="studio" && <Studio phenReady={phenReady} pragReady={pragReady} analReady={analReady} />}
            {tab==="review" && <Review scores={scores} student={student} />}
          </main>

          <footer className="py-6 text-center text-xs text-gray-500">
            ¬© {new Date().getFullYear()} Part 12 Workshop ¬∑ Saves locally ¬∑ Built for GitHub Pages
          </footer>
        </div>
      );
    }

    function Review({scores, student}) {
      const text = [
        "PART 12 ‚Äî COMPLETION SNAPSHOT",
        "--------------------------------",
        `Student: ${student.name} | ${student.email} | ${student.course}`,
        "",
        "Quick-Check Tally (‚â•1 per section suggests readiness for Studio):",
        `‚Ä¢ Phenomenology: ${scores.phenomenology}`,
        `‚Ä¢ Pragmatism:    ${scores.pragmatism}`,
        `‚Ä¢ Analytic:      ${scores.analytic}`,
        "",
        "Notes:",
        "This snapshot records section quick-check hits only. Use your Studio plan export for detailed workflow steps."
      ].join("\n");
      const blob = useMemo(()=> new Blob([text],{type:"text/plain"}), [text]);

      return (
        <SectionCard title="Review & Export" subtitle="Download a quick snapshot; your Studio plan can be exported there" icon="‚úÖ">
          <pre className="bg-gray-50 border rounded p-4 overflow-auto text-xs whitespace-pre-wrap">{text}</pre>
          <div className="flex gap-2 mt-3">
            <a className="px-3 py-2 rounded bg-indigo-600 text-white hover:bg-indigo-700" href={URL.createObjectURL(blob)} download="part12_snapshot.txt">Download Snapshot</a>
            <button className="px-3 py-2 rounded bg-gray-800 text-white hover:bg-black"
              onClick={()=>{ navigator.clipboard.writeText(text); alert("Snapshot copied."); }}>
              Copy Snapshot
            </button>
          </div>
        </SectionCard>
      );
    }

    /************ Mount ************/
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
